{"ast":null,"code":"var _jsxFileName = \"D:\\\\React\\\\lifeboat_online\\\\Lifeboat_Online\\\\clienty\\\\src\\\\3DObjects\\\\Ocean.js\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport * as THREE from \"three\";\nimport React, { useRef, useState, useMemo, useEffect } from \"react\";\nimport { extend, useFrame, useLoader } from \"@react-three/fiber\";\nimport { PlaneBufferGeometry } from \"three\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst uniforms = {\n  uTime: {\n    value: 0\n  },\n  bigElevation: {\n    value: 0.4\n  },\n  bigFrequency: {\n    value: new THREE.Vector2(0.7, 0.9)\n  },\n  bigSpeed: {\n    value: 0.5\n  }\n};\n\nconst shaderModifier = shader => {\n  shader.uniforms.uTime = uniforms.uTime;\n  shader.uniforms.bigElevation = uniforms.bigElevation;\n  shader.uniforms.bigFrequency = uniforms.bigFrequency;\n  shader.uniforms.bigSpeed = uniforms.bigSpeed; // add functions and uniforms\n\n  shader.vertexShader = shader.vertexShader.replace('#include <common>', `\n            #include <common>\n            uniform float uTime;\n            uniform float bigElevation;\n            uniform vec2 bigFrequency;\n            uniform float bigSpeed;\n\n            float calcElevation(vec3 position)\n            {\n                return sin(position.x * bigFrequency.x + uTime * bigSpeed) * sin(position.y * bigFrequency.y + uTime * bigSpeed) * bigElevation;\n            }\n\n            vec4 permute(vec4 x)\n            {\n                return mod(((x*34.0)+1.0)*x, 289.0);\n            }\n            vec4 taylorInvSqrt(vec4 r)\n            {\n                return 1.79284291400159 - 0.85373472095314 * r;\n            }\n            vec3 fade(vec3 t)\n            {\n                return t*t*t*(t*(t*6.0-15.0)+10.0);\n            }\n\n            float cnoise(vec3 P)\n            {\n                vec3 Pi0 = floor(P); // Integer part for indexing\n                vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n                Pi0 = mod(Pi0, 289.0);\n                Pi1 = mod(Pi1, 289.0);\n                vec3 Pf0 = fract(P); // Fractional part for interpolation\n                vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n                vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n                vec4 iy = vec4(Pi0.yy, Pi1.yy);\n                vec4 iz0 = Pi0.zzzz;\n                vec4 iz1 = Pi1.zzzz;\n\n                vec4 ixy = permute(permute(ix) + iy);\n                vec4 ixy0 = permute(ixy + iz0);\n                vec4 ixy1 = permute(ixy + iz1);\n\n                vec4 gx0 = ixy0 / 7.0;\n                vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n                gx0 = fract(gx0);\n                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n                vec4 sz0 = step(gz0, vec4(0.0));\n                gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n                gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n                vec4 gx1 = ixy1 / 7.0;\n                vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n                gx1 = fract(gx1);\n                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n                vec4 sz1 = step(gz1, vec4(0.0));\n                gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n                gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n                vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n                vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n                vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n                vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n                vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n                vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n                vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n                vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n                vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n                g000 *= norm0.x;\n                g010 *= norm0.y;\n                g100 *= norm0.z;\n                g110 *= norm0.w;\n                vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n                g001 *= norm1.x;\n                g011 *= norm1.y;\n                g101 *= norm1.z;\n                g111 *= norm1.w;\n\n                float n000 = dot(g000, Pf0);\n                float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n                float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n                float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n                float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n                float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n                float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n                float n111 = dot(g111, Pf1);\n\n                vec3 fade_xyz = fade(Pf0);\n                vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n                vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n                float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n                return 2.2 * n_xyz;\n            }\n        `); // actual calculation\n\n  shader.vertexShader = shader.vertexShader.replace(\"#include <begin_vertex>\", `\n            #include <begin_vertex>\n            \n            for(float i = 1.0; i <= 3.0; i++)\n            {\n                transformed.z = calcElevation(position) - abs(cnoise(vec3(position.xy * 3.0 * i, uTime * 0.15)) * 1.1 / i);\n            }\n        `); // shader.vertexShader = shader.vertexShader.replace(\n  //     '#include <beginnormal_vertex>',\n  //     `\n  //         #include <beginnormal_vertex>\n  //         vec3 currPos = vec3(position.x, position.y, calcElevation(position));\n  //         float increment = 5.0/16.0;\n  //         vec3 rightPos = vec3(position.x + increment, position.y, position.z);\n  //         vec3 bottomPos = vec3(position.x, position.y - increment, position.z);\n  //         vec3 elevatedRight = vec3(position.x + increment, position.y, calcElevation(rightPos));\n  //         vec3 elevatedBottom = vec3(position.x, position.y - increment, calcElevation(bottomPos));\n  //         vec3 edgeRight = elevatedRight - currPos;\n  //         vec3 edgeBottom = elevatedBottom - currPos;\n  //         vec3 crossProduct = cross(edgeBottom, edgeRight);\n  //         objectNormal = crossProduct;\n  //     `\n  // )\n};\n\nexport function Ocean(props) {\n  _s();\n\n  const oceanRef = useRef(); // Subscribe this component to the render-loop, rotate the mesh every frame\n\n  useFrame(_ref => {\n    let {\n      clock\n    } = _ref;\n    uniforms.uTime.value = clock.getElapsedTime();\n  }); // Return the view, these are regular Threejs elements expressed in JSX\n\n  return /*#__PURE__*/_jsxDEV(\"mesh\", { ...props,\n    ref: oceanRef,\n    \"rotation-x\": -Math.PI / 2,\n    receiveShadow: true,\n    children: [/*#__PURE__*/_jsxDEV(\"planeBufferGeometry\", {\n      args: [256, 128, 144, 108]\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 165,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"meshPhongMaterial\", {\n      color: new THREE.Color(0x00081b),\n      onBeforeCompile: shaderModifier,\n      transparent: true,\n      opacity: 0.8,\n      flatShading: true,\n      shininess: 80\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 168,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 158,\n    columnNumber: 9\n  }, this);\n}\n\n_s(Ocean, \"sOQAqKQ/V8yRZ59jPk+jqVIQMUk=\", false, function () {\n  return [useFrame];\n});\n\n_c = Ocean;\nexport function OceanBed() {\n  return /*#__PURE__*/_jsxDEV(\"mesh\", {\n    // rotation-x={-Math.PI / 2}\n    position: [0, 3, -5],\n    children: [/*#__PURE__*/_jsxDEV(\"planeBufferGeometry\", {\n      args: [100, 40]\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 187,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"meshPhongMaterial\", {\n      color: new THREE.Color(0x000000),\n      flatShading: true,\n      shininess: 0,\n      emmisive: 0x7799aa\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 190,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 183,\n    columnNumber: 9\n  }, this);\n}\n_c2 = OceanBed;\nexport function Box(props) {\n  _s2();\n\n  // This reference gives us direct access to the THREE.Mesh object\n  const ref = useRef(); // Hold state for hovered and clicked events\n\n  const [hovered, hover] = useState(false);\n  const [clicked, click] = useState(false); // Subscribe this component to the render-loop, rotate the mesh every frame\n\n  useFrame((state, delta) => ref.current.rotation.x += 0.01); // Return the view, these are regular Threejs elements expressed in JSX\n\n  return /*#__PURE__*/_jsxDEV(\"mesh\", { ...props,\n    ref: ref,\n    scale: clicked ? 1.5 : 1,\n    onClick: event => click(!clicked),\n    onPointerOver: event => hover(true),\n    onPointerOut: event => hover(false),\n    children: [/*#__PURE__*/_jsxDEV(\"boxGeometry\", {\n      args: [1, 1, 1]\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 217,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"meshStandardMaterial\", {\n      color: hovered ? 'hotpink' : 'orange'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 218,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 210,\n    columnNumber: 9\n  }, this);\n}\n\n_s2(Box, \"z4ku1cFD3MTB1blzCtJiPqYRyRY=\", false, function () {\n  return [useFrame];\n});\n\n_c3 = Box;\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"Ocean\");\n$RefreshReg$(_c2, \"OceanBed\");\n$RefreshReg$(_c3, \"Box\");","map":{"version":3,"sources":["D:/React/lifeboat_online/Lifeboat_Online/clienty/src/3DObjects/Ocean.js"],"names":["THREE","React","useRef","useState","useMemo","useEffect","extend","useFrame","useLoader","PlaneBufferGeometry","uniforms","uTime","value","bigElevation","bigFrequency","Vector2","bigSpeed","shaderModifier","shader","vertexShader","replace","Ocean","props","oceanRef","clock","getElapsedTime","Math","PI","Color","OceanBed","Box","ref","hovered","hover","clicked","click","state","delta","current","rotation","x","event"],"mappings":"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","sourcesContent":["import * as THREE from \"three\";\r\nimport React, { useRef, useState, useMemo, useEffect } from \"react\";\r\nimport { extend, useFrame, useLoader } from \"@react-three/fiber\";\r\nimport { PlaneBufferGeometry } from \"three\";\r\n\r\nconst uniforms = {\r\n    uTime: { value: 0 },\r\n    bigElevation: { value: 0.4 },\r\n    bigFrequency: { value: new THREE.Vector2(0.7, 0.9) },\r\n    bigSpeed: { value: 0.5 },\r\n}\r\n\r\nconst shaderModifier = (shader) => {\r\n    shader.uniforms.uTime = uniforms.uTime;\r\n    shader.uniforms.bigElevation = uniforms.bigElevation;\r\n    shader.uniforms.bigFrequency = uniforms.bigFrequency;\r\n    shader.uniforms.bigSpeed = uniforms.bigSpeed;\r\n    // add functions and uniforms\r\n    shader.vertexShader = shader.vertexShader.replace(\r\n        '#include <common>',\r\n        `\r\n            #include <common>\r\n            uniform float uTime;\r\n            uniform float bigElevation;\r\n            uniform vec2 bigFrequency;\r\n            uniform float bigSpeed;\r\n\r\n            float calcElevation(vec3 position)\r\n            {\r\n                return sin(position.x * bigFrequency.x + uTime * bigSpeed) * sin(position.y * bigFrequency.y + uTime * bigSpeed) * bigElevation;\r\n            }\r\n\r\n            vec4 permute(vec4 x)\r\n            {\r\n                return mod(((x*34.0)+1.0)*x, 289.0);\r\n            }\r\n            vec4 taylorInvSqrt(vec4 r)\r\n            {\r\n                return 1.79284291400159 - 0.85373472095314 * r;\r\n            }\r\n            vec3 fade(vec3 t)\r\n            {\r\n                return t*t*t*(t*(t*6.0-15.0)+10.0);\r\n            }\r\n\r\n            float cnoise(vec3 P)\r\n            {\r\n                vec3 Pi0 = floor(P); // Integer part for indexing\r\n                vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\r\n                Pi0 = mod(Pi0, 289.0);\r\n                Pi1 = mod(Pi1, 289.0);\r\n                vec3 Pf0 = fract(P); // Fractional part for interpolation\r\n                vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n                vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n                vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n                vec4 iz0 = Pi0.zzzz;\r\n                vec4 iz1 = Pi1.zzzz;\r\n\r\n                vec4 ixy = permute(permute(ix) + iy);\r\n                vec4 ixy0 = permute(ixy + iz0);\r\n                vec4 ixy1 = permute(ixy + iz1);\r\n\r\n                vec4 gx0 = ixy0 / 7.0;\r\n                vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\r\n                gx0 = fract(gx0);\r\n                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n                vec4 sz0 = step(gz0, vec4(0.0));\r\n                gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n                gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n\r\n                vec4 gx1 = ixy1 / 7.0;\r\n                vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\r\n                gx1 = fract(gx1);\r\n                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n                vec4 sz1 = step(gz1, vec4(0.0));\r\n                gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n                gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n\r\n                vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\r\n                vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\r\n                vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\r\n                vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\r\n                vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\r\n                vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\r\n                vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\r\n                vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\r\n\r\n                vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n                g000 *= norm0.x;\r\n                g010 *= norm0.y;\r\n                g100 *= norm0.z;\r\n                g110 *= norm0.w;\r\n                vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n                g001 *= norm1.x;\r\n                g011 *= norm1.y;\r\n                g101 *= norm1.z;\r\n                g111 *= norm1.w;\r\n\r\n                float n000 = dot(g000, Pf0);\r\n                float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n                float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n                float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n                float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n                float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n                float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n                float n111 = dot(g111, Pf1);\r\n\r\n                vec3 fade_xyz = fade(Pf0);\r\n                vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r\n                vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n                float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \r\n                return 2.2 * n_xyz;\r\n            }\r\n        `\r\n    )\r\n    // actual calculation\r\n    shader.vertexShader = shader.vertexShader.replace(\r\n        \"#include <begin_vertex>\",\r\n        `\r\n            #include <begin_vertex>\r\n            \r\n            for(float i = 1.0; i <= 3.0; i++)\r\n            {\r\n                transformed.z = calcElevation(position) - abs(cnoise(vec3(position.xy * 3.0 * i, uTime * 0.15)) * 1.1 / i);\r\n            }\r\n        `,\r\n    );\r\n    // shader.vertexShader = shader.vertexShader.replace(\r\n    //     '#include <beginnormal_vertex>',\r\n    //     `\r\n    //         #include <beginnormal_vertex>\r\n\r\n    //         vec3 currPos = vec3(position.x, position.y, calcElevation(position));\r\n    //         float increment = 5.0/16.0;\r\n\r\n    //         vec3 rightPos = vec3(position.x + increment, position.y, position.z);\r\n    //         vec3 bottomPos = vec3(position.x, position.y - increment, position.z);\r\n    //         vec3 elevatedRight = vec3(position.x + increment, position.y, calcElevation(rightPos));\r\n    //         vec3 elevatedBottom = vec3(position.x, position.y - increment, calcElevation(bottomPos));\r\n    //         vec3 edgeRight = elevatedRight - currPos;\r\n    //         vec3 edgeBottom = elevatedBottom - currPos;\r\n\r\n    //         vec3 crossProduct = cross(edgeBottom, edgeRight);\r\n    //         objectNormal = crossProduct;\r\n    //     `\r\n    // )\r\n}\r\n\r\n\r\nexport function Ocean(props) {\r\n    const oceanRef = useRef();\r\n    // Subscribe this component to the render-loop, rotate the mesh every frame\r\n    useFrame(({ clock }) => {\r\n        uniforms.uTime.value = clock.getElapsedTime();\r\n    });\r\n    // Return the view, these are regular Threejs elements expressed in JSX\r\n    return (\r\n        <mesh\r\n            {...props}\r\n            ref={oceanRef}\r\n            rotation-x={-Math.PI / 2}\r\n            receiveShadow={true}\r\n        >\r\n\r\n            <planeBufferGeometry\r\n                args={[256, 128, 144, 108]}\r\n            />\r\n            <meshPhongMaterial\r\n                color={new THREE.Color(0x00081b)}\r\n                onBeforeCompile={shaderModifier}\r\n                transparent={true}\r\n                opacity={0.8}\r\n                flatShading={true}\r\n                shininess={80}\r\n                \r\n            />\r\n        </mesh>\r\n    )\r\n}\r\n\r\nexport function OceanBed() {\r\n    return (\r\n        <mesh\r\n            // rotation-x={-Math.PI / 2}\r\n            position={[0, 3, -5]}\r\n        >\r\n            <planeBufferGeometry\r\n                args={[100, 40]}\r\n            />\r\n            <meshPhongMaterial\r\n                color={new THREE.Color(0x000000)}\r\n                flatShading={true}\r\n                shininess={0}\r\n                emmisive={0x7799aa}\r\n            />\r\n        </mesh>\r\n    )\r\n}\r\n\r\nexport function Box(props) {\r\n    // This reference gives us direct access to the THREE.Mesh object\r\n    const ref = useRef()\r\n    // Hold state for hovered and clicked events\r\n    const [hovered, hover] = useState(false)\r\n    const [clicked, click] = useState(false)\r\n    // Subscribe this component to the render-loop, rotate the mesh every frame\r\n    useFrame((state, delta) => (ref.current.rotation.x += 0.01))\r\n    // Return the view, these are regular Threejs elements expressed in JSX\r\n    return (\r\n        <mesh\r\n            {...props}\r\n            ref={ref}\r\n            scale={clicked ? 1.5 : 1}\r\n            onClick={(event) => click(!clicked)}\r\n            onPointerOver={(event) => hover(true)}\r\n            onPointerOut={(event) => hover(false)}>\r\n            <boxGeometry args={[1, 1, 1]} />\r\n            <meshStandardMaterial color={hovered ? 'hotpink' : 'orange'} />\r\n        </mesh>\r\n    )\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}